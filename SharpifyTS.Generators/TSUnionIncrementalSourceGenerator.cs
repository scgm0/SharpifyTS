using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SharpifyTS.Generators;

[Generator]
public sealed class TSUnionIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "SharpifyTS";
    private const string AttributeName = "TSUnionAttribute";
    private const string AttributeFullName = $"{Namespace}.{AttributeName}";

    private const string AttributeSourceCode = $$"""
                                                 // <auto-generated/>
                                                 using System;

                                                 namespace {{Namespace}}
                                                 {
                                                     [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class)]
                                                     public sealed class {{AttributeName}}(params Type[] types) : Attribute;
                                                 }
                                                 """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(AttributeFullName,
                static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
                static (ctx, _) => GenerateInfo.Extract(ctx.TargetSymbol))
            .Where(static info => info != default);

        context.RegisterSourceOutput(provider,
            (ctx, info) => ctx.AddSource($"{info.NamespaceName}.{info.TypeName}.g.cs", GenerateCode(info)));
    }

    private static string GenerateCode(GenerateInfo info)
    {
        var code = new StringBuilder($$"""
                                       // <auto-generated/>
                                       using System;

                                       namespace {{info.NamespaceName}};

                                       public partial {{info.TypeKey}} {{info.TypeName}}
                                       {
                                           public readonly object Value;

                                       """);
        foreach (var typedConstant in info.AttributeData.ConstructorArguments[0].Values)
        {
            code.Append($$"""
                          
                              public {{info.TypeName}}({{typedConstant.Value}} value)
                              {
                                  Value = value;
                              }
                          
                              public static implicit operator {{typedConstant.Value}}({{info.TypeName}} value)
                              {
                                  if (value.Value is {{typedConstant.Value}} valueValue)
                                      return valueValue;
                                  throw new InvalidCastException();
                              }
                          
                              public static implicit operator {{info.TypeName}}({{typedConstant.Value}} value)
                              {
                                  return new {{info.TypeName}}(value);
                              }

                          """);
        }

        code.Append("}");

        return code.ToString();
    }

    private readonly record struct GenerateInfo(
        string NamespaceName,
        string TypeName,
        string TypeKey,
        AttributeData AttributeData)
    {
        public string NamespaceName { get; } = NamespaceName;
        public string TypeName { get; } = TypeName;
        public string TypeKey { get; } = TypeKey;
        public AttributeData AttributeData { get; } = AttributeData;

        public static GenerateInfo Extract(ISymbol? symbol)
        {
            if (symbol is not ITypeSymbol type)
            {
                return default;
            }

            var namespaceName = type.ContainingNamespace.ToDisplayString();
            var typeName = type.Name;
            var typeKey = type.TypeKind.ToString().ToLower();
            var attributeData = type.GetAttributes()
                .FirstOrDefault(data => data.AttributeClass?.ToDisplayString() == AttributeFullName);
            return attributeData == null ? default : new GenerateInfo(namespaceName, typeName, typeKey, attributeData);
        }
    }
}