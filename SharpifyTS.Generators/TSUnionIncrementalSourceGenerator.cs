using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SharpifyTS.Generators;

[Generator]
public class TSUnionIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "SharpifyTS";
    private const string AttributeName = "TSUnionAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>
using System;

namespace {Namespace}
{{
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class)]
    public sealed class {AttributeName}(params Type[] types) : Attribute
    {{
        public Type[] Types {{ get; }} = types;
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName($"{Namespace}.{AttributeName}",
            static (node, _) => node is TypeDeclarationSyntax,
            static (ctx, _) =>
            {
                if (ctx.TargetSymbol is not ITypeSymbol typeSymbol) return null;
                return typeSymbol.GetAttributes()
                    .Select(data => data.AttributeClass!.ToDisplayString())
                    .Any(fullName => fullName == $"{Namespace}.{AttributeName}")
                    ? typeSymbol
                    : null;
            }).Where(static m => m is not null);

        context.RegisterSourceOutput(provider, (ctx, type) =>
        {
            if (type == null) return;
            var namespaceName = type.ContainingNamespace.ToDisplayString();
            var typeName = type.Name;
            var typeKey = type.TypeKind.ToString().ToLower();
            var code = $@"// <auto-generated/>
using System;

namespace {namespaceName};

public partial {typeKey} {typeName}
{{

    public readonly object Value;
{GenerateCode(ctx, typeName, type.GetAttributes())}
}}
";
            ctx.AddSource($"{namespaceName}.{typeName}.g.cs", SourceText.From(code, Encoding.UTF8));
        });
    }

    private static string GenerateCode(SourceProductionContext context, string name, ImmutableArray<AttributeData> attributes)
    {
        var code = "";
        foreach (var attributeData in attributes)
        {
            if (attributeData.AttributeClass?.ToDisplayString() != $"{Namespace}.{AttributeName}") continue;
            foreach (var argument in attributeData.ConstructorArguments[0].Values)
            {
                var type = argument.Value;
                code += $@"
    public {name}({type} value)
    {{
        Value = value;
    }}

    public static implicit operator {type}({name} value)
    {{
        if (value.Value is {type} valueValue)
            return valueValue;
        throw new InvalidCastException();
    }}

    public static implicit operator {name}({type} value)
    {{
        return new {name}(value);
    }}
";
            }
        }
        return code;
    }
}